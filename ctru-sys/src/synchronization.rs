/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

use Handle;
use svc::ResetType;
use super::lock::*;

pub type LightLock = _LOCK_T;
pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct LightEvent {
    pub state: i32,
    pub lock: LightLock,
}
impl ::core::default::Default for LightEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn __sync_get_arbiter() -> Handle;
    pub fn LightLock_Init(lock: *mut LightLock);
    pub fn LightLock_Lock(lock: *const LightLock);
    pub fn LightLock_TryLock(lock: *const LightLock) -> ::libc::c_int;
    pub fn LightLock_Unlock(lock: *const LightLock);
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
    pub fn RecursiveLock_Lock(lock: *const RecursiveLock);
    pub fn RecursiveLock_TryLock(lock: *const RecursiveLock) -> ::libc::c_int;
    pub fn RecursiveLock_Unlock(lock: *const RecursiveLock);
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
    pub fn LightEvent_Clear(event: *mut LightEvent);
    pub fn LightEvent_Pulse(event: *mut LightEvent);
    pub fn LightEvent_Signal(event: *mut LightEvent);
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
