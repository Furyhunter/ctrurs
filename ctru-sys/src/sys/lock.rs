/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
impl ::core::default::Default for __lock_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T)
     -> ::libc::c_int;
}
