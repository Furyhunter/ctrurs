/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum MemOp {
    MEMOP_FREE = 1,
    MEMOP_RESERVE = 2,
    MEMOP_ALLOC = 3,
    MEMOP_MAP = 4,
    MEMOP_UNMAP = 5,
    MEMOP_PROT = 6,
    MEMOP_REGION_APP = 256,
    MEMOP_REGION_SYSTEM = 512,
    MEMOP_REGION_BASE = 768,
    MEMOP_OP_MASK = 255,
    MEMOP_REGION_MASK = 3840,
    MEMOP_LINEAR_FLAG = 65536,
    MEMOP_ALLOC_LINEAR = 65539,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum MemState {
    MEMSTATE_FREE = 0,
    MEMSTATE_RESERVED = 1,
    MEMSTATE_IO = 2,
    MEMSTATE_STATIC = 3,
    MEMSTATE_CODE = 4,
    MEMSTATE_PRIVATE = 5,
    MEMSTATE_SHARED = 6,
    MEMSTATE_CONTINUOUS = 7,
    MEMSTATE_ALIASED = 8,
    MEMSTATE_ALIAS = 9,
    MEMSTATE_ALIASCODE = 10,
    MEMSTATE_LOCKED = 11,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum MemPerm {
    MEMPERM_READ = 1,
    MEMPERM_WRITE = 2,
    MEMPERM_EXECUTE = 4,
    MEMPERM_DONTCARE = 268435456,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct MemInfo {
    pub base_addr: u32_,
    pub size: u32_,
    pub perm: u32_,
    pub state: u32_,
}
impl ::core::default::Default for MemInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct PageInfo {
    pub flags: u32_,
}
impl ::core::default::Default for PageInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ArbitrationType {
    ARBITRATION_SIGNAL = 0,
    ARBITRATION_WAIT_IF_LESS_THAN = 1,
    ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN = 2,
    ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT = 3,
    ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ResetType { RESET_ONESHOT = 0, RESET_STICKY = 1, RESET_PULSE = 2, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ThreadInfoType { THREADINFO_TYPE_UNKNOWN = 0, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ProcessEventReason { REASON_CREATE = 1, REASON_ATTACH = 2, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ProcessEvent {
    pub program_id: u64_,
    pub process_name: [u8_; 8usize],
    pub process_id: u32_,
    pub reason: u32_,
}
impl ::core::default::Default for ProcessEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ExitProcessEventReason {
    EXITPROCESS_EVENT_NONE = 0,
    EXITPROCESS_EVENT_TERMINATE = 1,
    EXITPROCESS_EVENT_UNHANDLED_EXCEPTION = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ExitProcessEvent {
    pub reason: u32_,
}
impl ::core::default::Default for ExitProcessEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CreateThreadEvent {
    pub creator_thread_id: u32_,
    pub base_addr: u32_,
    pub entry_point: u32_,
}
impl ::core::default::Default for CreateThreadEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ExitThreadEventReason {
    EXITTHREAD_EVENT_NONE = 0,
    EXITTHREAD_EVENT_TERMINATE = 1,
    EXITTHREAD_EVENT_UNHANDLED_EXC = 2,
    EXITTHREAD_EVENT_TERMINATE_PROCESS = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ExitThreadEvent {
    pub reason: u32_,
}
impl ::core::default::Default for ExitThreadEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum UserBreakType {
    USERBREAK_PANIC = 0,
    USERBREAK_ASSERT = 1,
    USERBREAK_USER = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ExceptionEventType {
    EXC_EVENT_UNDEFINED_INSTRUCTION = 0,
    EXC_EVENT_UNKNOWN1 = 1,
    EXC_EVENT_UNKNOWN2 = 2,
    EXC_EVENT_UNKNOWN3 = 3,
    EXC_EVENT_ATTACH_BREAK = 4,
    EXC_EVENT_BREAKPOINT = 5,
    EXC_EVENT_USER_BREAK = 6,
    EXC_EVENT_DEBUGGER_BREAK = 7,
    EXC_EVENT_UNDEFINED_SYSCALL = 8,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct ExceptionEvent {
    pub type_: u32_,
    pub address: u32_,
    pub argument: u32_,
}
impl ::core::default::Default for ExceptionEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct SchedulerInOutEvent {
    pub clock_tick: u64_,
}
impl ::core::default::Default for SchedulerInOutEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct SyscallInOutEvent {
    pub clock_tick: u64_,
    pub syscall: u32_,
    _bindgen_padding_0_: [u8; 4usize],
}
impl ::core::default::Default for SyscallInOutEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct OutputStringEvent {
    pub string_addr: u32_,
    pub string_size: u32_,
}
impl ::core::default::Default for OutputStringEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct MapEvent {
    pub mapped_addr: u32_,
    pub mapped_size: u32_,
    pub memperm: u32_,
    pub memstate: u32_,
}
impl ::core::default::Default for MapEvent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum DebugEventType {
    DBG_EVENT_PROCESS = 0,
    DBG_EVENT_CREATE_THREAD = 1,
    DBG_EVENT_EXIT_THREAD = 2,
    DBG_EVENT_EXIT_PROCESS = 3,
    DBG_EVENT_EXCEPTION = 4,
    DBG_EVENT_DLL_LOAD = 5,
    DBG_EVENT_DLL_UNLOAD = 6,
    DBG_EVENT_SCHEDULE_IN = 7,
    DBG_EVENT_SCHEDULE_OUT = 8,
    DBG_EVENT_SYSCALL_IN = 9,
    DBG_EVENT_SYSCALL_OUT = 10,
    DBG_EVENT_OUTPUT_STRING = 11,
    DBG_EVENT_MAP = 12,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct DebugEventInfo {
    pub type_: u32_,
    pub thread_id: u32_,
    pub unknown: [u32_; 2usize],
    pub _bindgen_data_1_: [u64; 3usize],
}
impl DebugEventInfo {
    pub unsafe fn process(&mut self) -> *mut ProcessEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn create_thread(&mut self) -> *mut CreateThreadEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exit_thread(&mut self) -> *mut ExitThreadEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exit_process(&mut self) -> *mut ExitProcessEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exception(&mut self) -> *mut ExceptionEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn scheduler(&mut self) -> *mut SchedulerInOutEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn syscall(&mut self) -> *mut SyscallInOutEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn output_string(&mut self) -> *mut OutputStringEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn map(&mut self) -> *mut MapEvent {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for DebugEventInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CodeSetInfo {
    pub name: [u8_; 8usize],
    pub unk1: u16_,
    pub unk2: u16_,
    pub unk3: u32_,
    pub text_addr: u32_,
    pub text_size: u32_,
    pub ro_addr: u32_,
    pub ro_size: u32_,
    pub rw_addr: u32_,
    pub rw_size: u32_,
    pub text_size_total: u32_,
    pub ro_size_total: u32_,
    pub rw_size_total: u32_,
    pub unk4: u32_,
    pub program_id: u64_,
}
impl ::core::default::Default for CodeSetInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct StartupInfo {
    pub priority: ::libc::c_int,
    pub stack_size: u32_,
    pub argc: ::libc::c_int,
    pub argv: *mut u16_,
    pub envp: *mut u16_,
}
impl ::core::default::Default for StartupInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn svcControlMemory(addr_out: *mut u32_, addr0: u32_, addr1: u32_,
                            size: u32_, op: MemOp, perm: MemPerm) -> Result;
    pub fn svcControlProcessMemory(process: Handle, addr0: u32_, addr1: u32_,
                                   size: u32_, type_: u32_, perm: u32_)
     -> Result;
    pub fn svcCreateMemoryBlock(memblock: *mut Handle, addr: u32_, size: u32_,
                                my_perm: MemPerm, other_perm: MemPerm)
     -> Result;
    pub fn svcMapMemoryBlock(memblock: Handle, addr: u32_, my_perm: MemPerm,
                             other_perm: MemPerm) -> Result;
    pub fn svcMapProcessMemory(process: Handle, startAddr: u32_,
                               endAddr: u32_) -> Result;
    pub fn svcUnmapProcessMemory(process: Handle, startAddr: u32_,
                                 endAddr: u32_) -> Result;
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32_) -> Result;
    pub fn svcStartInterProcessDma(dma: *mut Handle, dstProcess: Handle,
                                   dst: *mut ::libc::c_void,
                                   srcProcess: Handle,
                                   src: *const ::libc::c_void, size: u32_,
                                   dmaConfig: *mut ::libc::c_void) -> Result;
    pub fn svcStopDma(dma: Handle) -> Result;
    pub fn svcGetDmaState(dmaState: *mut ::libc::c_void, dma: Handle)
     -> Result;
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32_)
     -> Result;
    pub fn svcQueryProcessMemory(info: *mut MemInfo, out: *mut PageInfo,
                                 process: Handle, addr: u32_) -> Result;
    pub fn svcInvalidateProcessDataCache(process: Handle,
                                         addr: *mut ::libc::c_void,
                                         size: u32_) -> Result;
    pub fn svcFlushProcessDataCache(process: Handle,
                                    addr: *const ::libc::c_void, size: u32_)
     -> Result;
    pub fn svcReadProcessMemory(buffer: *mut ::libc::c_void, debug: Handle,
                                addr: u32_, size: u32_) -> Result;
    pub fn svcWriteProcessMemory(debug: Handle, buffer: *const ::libc::c_void,
                                 addr: u32_, size: u32_) -> Result;
    pub fn svcOpenProcess(process: *mut Handle, processId: u32_) -> Result;
    pub fn svcExitProcess();
    pub fn svcTerminateProcess(process: Handle) -> Result;
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32_)
     -> Result;
    pub fn svcGetProcessId(out: *mut u32_, handle: Handle) -> Result;
    pub fn svcGetProcessList(processCount: *mut s32, processIds: *mut u32_,
                             processIdMaxCount: s32) -> Result;
    pub fn svcCreatePort(portServer: *mut Handle, portClient: *mut Handle,
                         name: *const ::libc::c_char, maxSessions: s32)
     -> Result;
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char)
     -> Result;
    pub fn svcCreateCodeSet(out: *mut Handle, info: *const CodeSetInfo,
                            code_ptr: *mut ::libc::c_void,
                            ro_ptr: *mut ::libc::c_void,
                            data_ptr: *mut ::libc::c_void) -> Result;
    pub fn svcCreateProcess(out: *mut Handle, codeset: Handle,
                            arm11kernelcaps: *const u32_,
                            arm11kernelcaps_num: u32_) -> Result;
    pub fn svcSetProcessAffinityMask(process: Handle,
                                     affinitymask: *const u8_,
                                     processorcount: s32) -> Result;
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32)
     -> Result;
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
    pub fn svcCreateThread(thread: *mut Handle, entrypoint: ThreadFunc,
                           arg: u32_, stack_top: *mut u32_,
                           thread_priority: s32, processor_id: s32) -> Result;
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32_)
     -> Result;
    pub fn svcExitThread();
    pub fn svcSleepThread(ns: s64);
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
    pub fn svcGetThreadAffinityMask(affinitymask: *mut u8_, thread: Handle,
                                    processorcount: s32) -> Result;
    pub fn svcSetThreadAffinityMask(thread: Handle, affinitymask: *const u8_,
                                    processorcount: s32) -> Result;
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle)
     -> Result;
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32)
     -> Result;
    pub fn svcGetProcessorID() -> s32;
    pub fn svcGetThreadId(out: *mut u32_, handle: Handle) -> Result;
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle)
     -> Result;
    pub fn svcGetResourceLimitLimitValues(values: *mut s64,
                                          resourceLimit: Handle,
                                          names: *mut u32_, nameCount: s32)
     -> Result;
    pub fn svcGetResourceLimitCurrentValues(values: *mut s64,
                                            resourceLimit: Handle,
                                            names: *mut u32_, nameCount: s32)
     -> Result;
    pub fn svcGetProcessIdOfThread(out: *mut u32_, handle: Handle) -> Result;
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle,
                            type_: ThreadInfoType) -> Result;
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: u8) -> Result;
    pub fn svcReleaseMutex(handle: Handle) -> Result;
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32,
                              max_count: s32) -> Result;
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle,
                               release_count: s32) -> Result;
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType)
     -> Result;
    pub fn svcSignalEvent(handle: Handle) -> Result;
    pub fn svcClearEvent(handle: Handle) -> Result;
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
    pub fn svcWaitSynchronizationN(out: *mut s32, handles: *mut Handle,
                                   handles_num: s32, wait_all: u8,
                                   nanoseconds: s64) -> Result;
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
    pub fn svcArbitrateAddress(arbiter: Handle, addr: u32_,
                               type_: ArbitrationType, value: s32,
                               nanoseconds: s64) -> Result;
    pub fn svcSendSyncRequest(session: Handle) -> Result;
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
    pub fn svcReplyAndReceive(index: *mut s32, handles: *mut Handle,
                              handleCount: s32, replyTarget: Handle)
     -> Result;
    pub fn svcBindInterrupt(interruptId: u32_, event: Handle, priority: s32,
                            isManualClear: u8) -> Result;
    pub fn svcUnbindInterrupt(interruptId: u32_, event: Handle) -> Result;
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType)
     -> Result;
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
    pub fn svcCancelTimer(timer: Handle) -> Result;
    pub fn svcClearTimer(timer: Handle) -> Result;
    pub fn svcGetSystemTick() -> u64_;
    pub fn svcCloseHandle(handle: Handle) -> Result;
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32_, param: s32) -> Result;
    pub fn svcKernelSetState(type_: u32_, param0: u32_, param1: u32_,
                             param2: u32_) -> Result;
    pub fn svcBreak(breakReason: UserBreakType);
    pub fn svcOutputDebugString(str: *const ::libc::c_char,
                                length: ::libc::c_int) -> Result;
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32_)
     -> Result;
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle)
     -> Result;
    pub fn svcContinueDebugEvent(debug: Handle, flags: u32_) -> Result;
    pub fn svcBackdoor(callback:
                           ::core::option::Option<extern "C" fn() -> s32>)
     -> Result;
}

use ::types::*;
