/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed1 {
    FS_OPEN_READ = 1,
    FS_OPEN_WRITE = 2,
    FS_OPEN_CREATE = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed2 { FS_WRITE_FLUSH = 1, FS_WRITE_UPDATE_TIME = 256, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed3 {
    FS_ATTRIBUTE_DIRECTORY = 1,
    FS_ATTRIBUTE_HIDDEN = 256,
    FS_ATTRIBUTE_ARCHIVE = 65536,
    FS_ATTRIBUTE_READ_ONLY = 16777216,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_MediaType {
    MEDIATYPE_NAND = 0,
    MEDIATYPE_SD = 1,
    MEDIATYPE_GAME_CARD = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_SystemMediaType {
    SYSTEM_MEDIATYPE_CTR_NAND = 0,
    SYSTEM_MEDIATYPE_TWL_NAND = 1,
    SYSTEM_MEDIATYPE_SD = 2,
    SYSTEM_MEDIATYPE_TWL_PHOTO = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_ArchiveID {
    ARCHIVE_ROMFS = 3,
    ARCHIVE_SAVEDATA = 4,
    ARCHIVE_EXTDATA = 6,
    ARCHIVE_SHARED_EXTDATA = 7,
    ARCHIVE_SYSTEM_SAVEDATA = 8,
    ARCHIVE_SDMC = 9,
    ARCHIVE_SDMC_WRITE_ONLY = 10,
    ARCHIVE_BOSS_EXTDATA = 305419896,
    ARCHIVE_CARD_SPIFS = 305419897,
    ARCHIVE_EXTDATA_AND_BOSS_EXTDATA = 305419899,
    ARCHIVE_SYSTEM_SAVEDATA2 = 305419900,
    ARCHIVE_NAND_RW = 305419901,
    ARCHIVE_NAND_RO = 305419902,
    ARCHIVE_NAND_RO_WRITE_ACCESS = 305419903,
    ARCHIVE_SAVEDATA_AND_CONTENT = 591751050,
    ARCHIVE_SAVEDATA_AND_CONTENT2 = 591751054,
    ARCHIVE_NAND_CTR_FS = 1450741931,
    ARCHIVE_TWL_PHOTO = 1450741932,
    ARCHIVE_TWL_SOUND = 1450741933,
    ARCHIVE_NAND_TWL_FS = 1450741934,
    ARCHIVE_NAND_W_FS = 1450741935,
    ARCHIVE_GAMECARD_SAVEDATA = 1450741937,
    ARCHIVE_USER_SAVEDATA = 1450741938,
    ARCHIVE_DEMO_SAVEDATA = 1450741940,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_PathType {
    PATH_INVALID = 0,
    PATH_EMPTY = 1,
    PATH_BINARY = 2,
    PATH_ASCII = 3,
    PATH_UTF16 = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_SecureValueSlot { SECUREVALUE_SLOT_SD = 4096, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_CardSpiBaudRate {
    BAUDRATE_512KHZ = 0,
    BAUDRATE_1MHZ = 1,
    BAUDRATE_2MHZ = 2,
    BAUDRATE_4MHZ = 3,
    BAUDRATE_8MHZ = 4,
    BAUDRATE_16MHZ = 5,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_CardSpiBusMode { BUSMODE_1BIT = 0, BUSMODE_4BIT = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_SpecialContentType {
    SPECIALCONTENT_UPDATE = 1,
    SPECIALCONTENT_MANUAL = 2,
    SPECIALCONTENT_DLP_CHILD = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_CardType { CARD_CTR = 0, CARD_TWL = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_Action { FS_ACTION_UNKNOWN = 0, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_ArchiveAction {
    ARCHIVE_ACTION_COMMIT_SAVE_DATA = 0,
    ARCHIVE_ACTION_GET_TIMESTAMP = 1,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_SecureSaveAction {
    SECURESAVE_ACTION_DELETE = 0,
    SECURESAVE_ACTION_FORMAT = 1,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_FileAction { FILE_ACTION_UNKNOWN = 0, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FS_DirectoryAction { DIRECTORY_ACTION_UNKNOWN = 0, }
#[repr(C)]
#[derive(Copy)]
pub struct FS_DirectoryEntry {
    pub name: [u16_; 262usize],
    pub shortName: [::libc::c_char; 10usize],
    pub shortExt: [::libc::c_char; 4usize],
    pub valid: u8_,
    pub reserved: u8_,
    pub attributes: u32_,
    pub fileSize: u64_,
}
impl ::core::clone::Clone for FS_DirectoryEntry {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for FS_DirectoryEntry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_ArchiveResource {
    pub sectorSize: u32_,
    pub clusterSize: u32_,
    pub totalClusters: u32_,
    pub freeClusters: u32_,
}
impl ::core::default::Default for FS_ArchiveResource {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_ProgramInfo {
    pub programId: u64_,
    pub _bindgen_bitfield_1_: FS_MediaType,
    pub padding: [u8_; 7usize],
}
impl ::core::default::Default for FS_ProgramInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_ProductInfo {
    pub productCode: [::libc::c_char; 16usize],
    pub companyCode: [::libc::c_char; 2usize],
    pub remasterVersion: u16_,
}
impl ::core::default::Default for FS_ProductInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_IntegrityVerificationSeed {
    pub aesCbcMac: [u8_; 16usize],
    pub movableSed: [u8_; 288usize],
}
impl ::core::clone::Clone for FS_IntegrityVerificationSeed {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for FS_IntegrityVerificationSeed {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_ExtSaveDataInfo {
    pub _bindgen_bitfield_1_: FS_MediaType,
    pub unknown: u8_,
    pub reserved1: u16_,
    pub saveId: u64_,
    pub reserved2: u32_,
}
impl ::core::default::Default for FS_ExtSaveDataInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_SystemSaveDataInfo {
    pub _bindgen_bitfield_1_: FS_MediaType,
    pub unknown: u8_,
    pub reserved: u16_,
    pub saveId: u32_,
}
impl ::core::default::Default for FS_SystemSaveDataInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_DeviceMoveContext {
    pub ivs: [u8_; 16usize],
    pub encryptParameter: [u8_; 16usize],
}
impl ::core::default::Default for FS_DeviceMoveContext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct FS_Path {
    pub type_: FS_PathType,
    pub size: u32_,
    pub data: *const ::libc::c_void,
}
impl ::core::default::Default for FS_Path {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type FS_Archive = u64_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct romfs_header {
    pub headerSize: u32_,
    pub dirHashTableOff: u32_,
    pub dirHashTableSize: u32_,
    pub dirTableOff: u32_,
    pub dirTableSize: u32_,
    pub fileHashTableOff: u32_,
    pub fileHashTableSize: u32_,
    pub fileTableOff: u32_,
    pub fileTableSize: u32_,
    pub fileDataOff: u32_,
}
impl ::core::default::Default for romfs_header {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct romfs_dir {
    pub parent: u32_,
    pub sibling: u32_,
    pub childDir: u32_,
    pub childFile: u32_,
    pub nextHash: u32_,
    pub nameLen: u32_,
    pub name: [u16_; 0usize],
}
impl ::core::default::Default for romfs_dir {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct romfs_file {
    pub parent: u32_,
    pub sibling: u32_,
    pub dataOff: u64_,
    pub dataSize: u64_,
    pub nextHash: u32_,
    pub nameLen: u32_,
    pub name: [u16_; 0usize],
}
impl ::core::default::Default for romfs_file {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub enum romfs_mount { }
extern "C" {
    pub fn fsInit() -> Result;
    pub fn fsExit();
    pub fn fsUseSession(session: Handle);
    pub fn fsEndUseSession();
    pub fn fsExemptFromSession(archive: FS_Archive);
    pub fn fsUnexemptFromSession(archive: FS_Archive);
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void)
     -> FS_Path;
    pub fn fsGetSessionHandle() -> *mut Handle;
    pub fn FSUSER_Control(action: FS_Action, input: *mut ::libc::c_void,
                          inputSize: u32_, output: *mut ::libc::c_void,
                          outputSize: u32_) -> Result;
    pub fn FSUSER_Initialize(session: Handle) -> Result;
    pub fn FSUSER_OpenFile(out: *mut Handle, archive: FS_Archive,
                           path: FS_Path, openFlags: u32_, attributes: u32_)
     -> Result;
    pub fn FSUSER_OpenFileDirectly(out: *mut Handle, archiveId: FS_ArchiveID,
                                   archivePath: FS_Path, filePath: FS_Path,
                                   openFlags: u32_, attributes: u32_)
     -> Result;
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
    pub fn FSUSER_RenameFile(srcArchive: FS_Archive, srcPath: FS_Path,
                             dstArchive: FS_Archive, dstPath: FS_Path)
     -> Result;
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path)
     -> Result;
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive,
                                             path: FS_Path) -> Result;
    pub fn FSUSER_CreateFile(archive: FS_Archive, path: FS_Path,
                             attributes: u32_, fileSize: u64_) -> Result;
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path,
                                  attributes: u32_) -> Result;
    pub fn FSUSER_RenameDirectory(srcArchive: FS_Archive, srcPath: FS_Path,
                                  dstArchive: FS_Archive, dstPath: FS_Path)
     -> Result;
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive,
                                path: FS_Path) -> Result;
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID,
                              path: FS_Path) -> Result;
    pub fn FSUSER_ControlArchive(archive: FS_Archive,
                                 action: FS_ArchiveAction,
                                 input: *mut ::libc::c_void, inputSize: u32_,
                                 output: *mut ::libc::c_void,
                                 outputSize: u32_) -> Result;
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64_, archive: FS_Archive)
     -> Result;
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource:
                                             *mut FS_ArchiveResource)
     -> Result;
    pub fn FSUSER_GetNandArchiveResource(archiveResource:
                                             *mut FS_ArchiveResource)
     -> Result;
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32_) -> Result;
    pub fn FSUSER_IsSdmcDetected(detected: *mut u8) -> Result;
    pub fn FSUSER_IsSdmcWritable(writable: *mut u8) -> Result;
    pub fn FSUSER_GetSdmcCid(out: *mut u8_, length: u32_) -> Result;
    pub fn FSUSER_GetNandCid(out: *mut u8_, length: u32_) -> Result;
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut u32_) -> Result;
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut u32_) -> Result;
    pub fn FSUSER_GetSdmcLog(out: *mut u8_, length: u32_) -> Result;
    pub fn FSUSER_GetNandLog(out: *mut u8_, length: u32_) -> Result;
    pub fn FSUSER_ClearSdmcLog() -> Result;
    pub fn FSUSER_ClearNandLog() -> Result;
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut u8) -> Result;
    pub fn FSUSER_CardSlotPowerOn(status: *mut u8) -> Result;
    pub fn FSUSER_CardSlotPowerOff(status: *mut u8) -> Result;
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut u8) -> Result;
    pub fn FSUSER_CardNorDirectCommand(commandId: u8_) -> Result;
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8_,
                                                  address: u32_) -> Result;
    pub fn FSUSER_CardNorDirectRead(commandId: u8_, size: u32_,
                                    output: *mut u8_) -> Result;
    pub fn FSUSER_CardNorDirectReadWithAddress(commandId: u8_, address: u32_,
                                               size: u32_, output: *mut u8_)
     -> Result;
    pub fn FSUSER_CardNorDirectWrite(commandId: u8_, size: u32_,
                                     input: *mut u8_) -> Result;
    pub fn FSUSER_CardNorDirectWriteWithAddress(commandId: u8_, address: u32_,
                                                size: u32_, input: *mut u8_)
     -> Result;
    pub fn FSUSER_CardNorDirectRead_4xIO(commandId: u8_, address: u32_,
                                         size: u32_, output: *mut u8_)
     -> Result;
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(address: u32_,
                                                     size: u32_,
                                                     input: *mut u8_)
     -> Result;
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32_)
     -> Result;
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32_)
     -> Result;
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo,
                                       processId: u32_) -> Result;
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
    pub fn FSUSER_GetSpecialContentIndex(index: *mut u16_,
                                         mediaType: FS_MediaType,
                                         programId: u64_,
                                         type_: FS_SpecialContentType)
     -> Result;
    pub fn FSUSER_GetLegacyRomHeader(mediaType: FS_MediaType, programId: u64_,
                                     header: *mut u8_) -> Result;
    pub fn FSUSER_GetLegacyBannerData(mediaType: FS_MediaType,
                                      programId: u64_, banner: *mut u8_)
     -> Result;
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(access: *mut u8,
                                                    mediaType: FS_MediaType,
                                                    saveId: u64_,
                                                    processId: u32_)
     -> Result;
    pub fn FSUSER_QueryTotalQuotaSize(quotaSize: *mut u64_, directories: u32_,
                                      files: u32_, fileSizeCount: u32_,
                                      fileSizes: *mut u64_) -> Result;
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32_) -> Result;
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
    pub fn FSUSER_CreateSeed() -> Result;
    pub fn FSUSER_GetFormatInfo(totalSize: *mut u32_, directories: *mut u32_,
                                files: *mut u32_, duplicateData: *mut u8,
                                archiveId: FS_ArchiveID, path: FS_Path)
     -> Result;
    pub fn FSUSER_GetLegacyRomHeader2(headerSize: u32_,
                                      mediaType: FS_MediaType,
                                      programId: u64_, header: *mut u8_)
     -> Result;
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8_, length: u32_) -> Result;
    pub fn FSUSER_GetArchiveResource(archiveResource: *mut FS_ArchiveResource,
                                     mediaType: FS_SystemMediaType) -> Result;
    pub fn FSUSER_ExportIntegrityVerificationSeed(seed:
                                                      *mut FS_IntegrityVerificationSeed)
     -> Result;
    pub fn FSUSER_ImportIntegrityVerificationSeed(seed:
                                                      *mut FS_IntegrityVerificationSeed)
     -> Result;
    pub fn FSUSER_FormatSaveData(archiveId: FS_ArchiveID, path: FS_Path,
                                 blocks: u32_, directories: u32_, files: u32_,
                                 directoryBuckets: u32_, fileBuckets: u32_,
                                 duplicateData: u8) -> Result;
    pub fn FSUSER_GetLegacySubBannerData(bannerSize: u32_,
                                         mediaType: FS_MediaType,
                                         programId: u64_, banner: *mut u8_)
     -> Result;
    pub fn FSUSER_UpdateSha256Context(data: *const ::libc::c_void,
                                      inputSize: u32_, hash: *mut u8_)
     -> Result;
    pub fn FSUSER_ReadSpecialFile(bytesRead: *mut u32_, fileOffset: u64_,
                                  size: u32_, data: *mut u8_) -> Result;
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64_) -> Result;
    pub fn FSUSER_CreateExtSaveData(info: FS_ExtSaveDataInfo,
                                    directories: u32_, files: u32_,
                                    sizeLimit: u64_, smdhSize: u32_,
                                    smdh: *mut u8_) -> Result;
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
    pub fn FSUSER_ReadExtSaveDataIcon(bytesRead: *mut u32_,
                                      info: FS_ExtSaveDataInfo,
                                      smdhSize: u32_, smdh: *mut u8_)
     -> Result;
    pub fn FSUSER_GetExtDataBlockSize(totalBlocks: *mut u64_,
                                      freeBlocks: *mut u64_,
                                      blockSize: *mut u32_,
                                      info: FS_ExtSaveDataInfo) -> Result;
    pub fn FSUSER_EnumerateExtSaveData(idsWritten: *mut u32_, idsSize: u32_,
                                       mediaType: FS_MediaType, idSize: u32_,
                                       shared: u8, ids: *mut u8_) -> Result;
    pub fn FSUSER_CreateSystemSaveData(info: FS_SystemSaveDataInfo,
                                       totalSize: u32_, blockSize: u32_,
                                       directories: u32_, files: u32_,
                                       directoryBuckets: u32_,
                                       fileBuckets: u32_, duplicateData: u8)
     -> Result;
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext)
     -> Result;
    pub fn FSUSER_StartDeviceMoveAsDestination(context: FS_DeviceMoveContext,
                                               clear: u8) -> Result;
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32_)
     -> Result;
    pub fn FSUSER_GetArchivePriority(priority: *mut u32_, archive: FS_Archive)
     -> Result;
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64_,
                                             emulateEndurance: u8) -> Result;
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: u8) -> Result;
    pub fn FSUSER_EnumerateSystemSaveData(idsWritten: *mut u32_,
                                          idsSize: u32_, ids: *mut u32_)
     -> Result;
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32_)
     -> Result;
    pub fn FSUSER_SetPriority(priority: u32_) -> Result;
    pub fn FSUSER_GetPriority(priority: *mut u32_) -> Result;
    pub fn FSUSER_SetSaveDataSecureValue(value: u64_,
                                         slot: FS_SecureValueSlot,
                                         titleUniqueId: u32_,
                                         titleVariation: u8_) -> Result;
    pub fn FSUSER_GetSaveDataSecureValue(exists: *mut u8, value: *mut u64_,
                                         slot: FS_SecureValueSlot,
                                         titleUniqueId: u32_,
                                         titleVariation: u8_) -> Result;
    pub fn FSUSER_ControlSecureSave(action: FS_SecureSaveAction,
                                    input: *mut ::libc::c_void,
                                    inputSize: u32_,
                                    output: *mut ::libc::c_void,
                                    outputSize: u32_) -> Result;
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
    pub fn FSFILE_Control(handle: Handle, action: FS_FileAction,
                          input: *mut ::libc::c_void, inputSize: u32_,
                          output: *mut ::libc::c_void, outputSize: u32_)
     -> Result;
    pub fn FSFILE_OpenSubFile(handle: Handle, subFile: *mut Handle,
                              offset: u64_, size: u64_) -> Result;
    pub fn FSFILE_Read(handle: Handle, bytesRead: *mut u32_, offset: u64_,
                       buffer: *mut ::libc::c_void, size: u32_) -> Result;
    pub fn FSFILE_Write(handle: Handle, bytesWritten: *mut u32_, offset: u64_,
                        buffer: *const ::libc::c_void, size: u32_,
                        flags: u32_) -> Result;
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64_) -> Result;
    pub fn FSFILE_SetSize(handle: Handle, size: u64_) -> Result;
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32_)
     -> Result;
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32_) -> Result;
    pub fn FSFILE_Close(handle: Handle) -> Result;
    pub fn FSFILE_Flush(handle: Handle) -> Result;
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32_) -> Result;
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle)
     -> Result;
    pub fn FSDIR_Control(handle: Handle, action: FS_DirectoryAction,
                         input: *mut ::libc::c_void, inputSize: u32_,
                         output: *mut ::libc::c_void, outputSize: u32_)
     -> Result;
    pub fn FSDIR_Read(handle: Handle, entriesRead: *mut u32_,
                      entryCount: u32_, entries: *mut FS_DirectoryEntry)
     -> Result;
    pub fn FSDIR_Close(handle: Handle) -> Result;
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32_) -> Result;
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
    pub fn romfsMount(mount: *mut *mut romfs_mount) -> Result;
    pub fn romfsMountFromFile(file: Handle, offset: u32_,
                              mount: *mut *mut romfs_mount) -> Result;
    pub fn romfsBind(mount: *mut romfs_mount) -> Result;
    pub fn romfsUnmount(mount: *mut romfs_mount) -> Result;
}

use ::types::*;
