/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct httpcContext {
    pub servhandle: Handle,
    pub httphandle: u32_,
}
impl ::core::default::Default for httpcContext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HTTPC_RequestMethod {
    HTTPC_METHOD_GET = 1,
    HTTPC_METHOD_POST = 2,
    HTTPC_METHOD_HEAD = 3,
    HTTPC_METHOD_PUT = 4,
    HTTPC_METHOD_DELETE = 5,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HTTPC_RequestStatus {
    HTTPC_STATUS_REQUEST_IN_PROGRESS = 5,
    HTTPC_STATUS_DOWNLOAD_READY = 7,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HTTPC_KeepAlive {
    HTTPC_KEEPALIVE_DISABLED = 0,
    HTTPC_KEEPALIVE_ENABLED = 1,
}
extern "C" {
    pub fn httpcInit(sharedmem_size: u32_) -> Result;
    pub fn httpcExit();
    pub fn httpcOpenContext(context: *mut httpcContext,
                            method: HTTPC_RequestMethod,
                            url: *const ::libc::c_char,
                            use_defaultproxy: u32_) -> Result;
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
    pub fn httpcAddRequestHeaderField(context: *mut httpcContext,
                                      name: *const ::libc::c_char,
                                      value: *const ::libc::c_char) -> Result;
    pub fn httpcAddPostDataAscii(context: *mut httpcContext,
                                 name: *const ::libc::c_char,
                                 value: *const ::libc::c_char) -> Result;
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32_,
                               len: u32_) -> Result;
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8_,
                            size: u32_) -> Result;
    pub fn httpcReceiveDataTimeout(context: *mut httpcContext,
                                   buffer: *mut u8_, size: u32_,
                                   timeout: u64_) -> Result;
    pub fn httpcGetRequestState(context: *mut httpcContext,
                                out: *mut HTTPC_RequestStatus) -> Result;
    pub fn httpcGetDownloadSizeState(context: *mut httpcContext,
                                     downloadedsize: *mut u32_,
                                     contentsize: *mut u32_) -> Result;
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext,
                                      out: *mut u32_) -> Result;
    pub fn httpcGetResponseStatusCodeTimeout(context: *mut httpcContext,
                                             out: *mut u32_, timeout: u64_)
     -> Result;
    pub fn httpcGetResponseHeader(context: *mut httpcContext,
                                  name: *const ::libc::c_char,
                                  value: *mut ::libc::c_char,
                                  valuebuf_maxsize: u32_) -> Result;
    pub fn httpcAddTrustedRootCA(context: *mut httpcContext, cert: *const u8_,
                                 certsize: u32_) -> Result;
    pub fn httpcAddDefaultCert(context: *mut httpcContext,
                               certID: SSLC_DefaultRootCert) -> Result;
    pub fn httpcSelectRootCertChain(context: *mut httpcContext,
                                    RootCertChain_contexthandle: u32_)
     -> Result;
    pub fn httpcSetClientCert(context: *mut httpcContext, cert: *const u8_,
                              certsize: u32_, privk: *const u8_,
                              privk_size: u32_) -> Result;
    pub fn httpcSetClientCertDefault(context: *mut httpcContext,
                                     certID: SSLC_DefaultClientCert)
     -> Result;
    pub fn httpcSetClientCertContext(context: *mut httpcContext,
                                     ClientCert_contexthandle: u32_)
     -> Result;
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32_)
     -> Result;
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32_)
     -> Result;
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_)
     -> Result;
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32_)
     -> Result;
    pub fn httpcRootCertChainAddCert(RootCertChain_contexthandle: u32_,
                                     cert: *const u8_, certsize: u32_,
                                     cert_contexthandle: *mut u32_) -> Result;
    pub fn httpcRootCertChainAddDefaultCert(RootCertChain_contexthandle: u32_,
                                            certID: SSLC_DefaultRootCert,
                                            cert_contexthandle: *mut u32_)
     -> Result;
    pub fn httpcRootCertChainRemoveCert(RootCertChain_contexthandle: u32_,
                                        cert_contexthandle: u32_) -> Result;
    pub fn httpcOpenClientCertContext(cert: *const u8_, certsize: u32_,
                                      privk: *const u8_, privk_size: u32_,
                                      ClientCert_contexthandle: *mut u32_)
     -> Result;
    pub fn httpcOpenDefaultClientCertContext(certID: SSLC_DefaultClientCert,
                                             ClientCert_contexthandle:
                                                 *mut u32_) -> Result;
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32_)
     -> Result;
    pub fn httpcDownloadData(context: *mut httpcContext, buffer: *mut u8_,
                             size: u32_, downloadedsize: *mut u32_) -> Result;
    pub fn httpcSetKeepAlive(context: *mut httpcContext,
                             option: HTTPC_KeepAlive) -> Result;
}
use ::types::*;
use super::sslc::*;
