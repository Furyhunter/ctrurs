/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct GSPGPU_FramebufferInfo {
    pub active_framebuf: u32_,
    pub framebuf0_vaddr: *mut u32_,
    pub framebuf1_vaddr: *mut u32_,
    pub framebuf_widthbytesize: u32_,
    pub format: u32_,
    pub framebuf_dispselect: u32_,
    pub unk: u32_,
}
impl ::core::default::Default for GSPGPU_FramebufferInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GSPGPU_FramebufferFormats {
    GSP_RGBA8_OES = 0,
    GSP_BGR8_OES = 1,
    GSP_RGB565_OES = 2,
    GSP_RGB5_A1_OES = 3,
    GSP_RGBA4_OES = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct GSPGPU_CaptureInfoEntry {
    pub framebuf0_vaddr: *mut u32_,
    pub framebuf1_vaddr: *mut u32_,
    pub format: u32_,
    pub framebuf_widthbytesize: u32_,
}
impl ::core::default::Default for GSPGPU_CaptureInfoEntry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct GSPGPU_CaptureInfo {
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
impl ::core::default::Default for GSPGPU_CaptureInfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GSPGPU_Event {
    GSPGPU_EVENT_PSC0 = 0,
    GSPGPU_EVENT_PSC1 = 1,
    GSPGPU_EVENT_VBlank0 = 2,
    GSPGPU_EVENT_VBlank1 = 3,
    GSPGPU_EVENT_PPF = 4,
    GSPGPU_EVENT_P3D = 5,
    GSPGPU_EVENT_DMA = 6,
    GSPGPU_EVENT_MAX = 7,
}
extern "C" {
    pub fn gspInit() -> Result;
    pub fn gspExit();
    pub fn gspSetEventCallback(id: GSPGPU_Event, cb: ThreadFunc,
                               data: *mut ::libc::c_void, oneShot: u8);
    pub fn gspInitEventHandler(gspEvent: Handle, gspSharedMem: *mut vu8,
                               gspThreadId: u8_) -> Result;
    pub fn gspExitEventHandler();
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: u8);
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
    pub fn gspSubmitGxCommand(sharedGspCmdBuf: *mut u32_,
                              gxCommand: *mut u32_) -> Result;
    pub fn GSPGPU_AcquireRight(flags: u8_) -> Result;
    pub fn GSPGPU_ReleaseRight() -> Result;
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo:
                                               *mut GSPGPU_CaptureInfo)
     -> Result;
    pub fn GSPGPU_SaveVramSysArea() -> Result;
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
    pub fn GSPGPU_SetLcdForceBlack(flags: u8_) -> Result;
    pub fn GSPGPU_SetBufferSwap(screenid: u32_,
                                framebufinfo: *mut GSPGPU_FramebufferInfo)
     -> Result;
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32_)
     -> Result;
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_)
     -> Result;
    pub fn GSPGPU_WriteHWRegs(regAddr: u32_, data: *mut u32_, size: u8_)
     -> Result;
    pub fn GSPGPU_WriteHWRegsWithMask(regAddr: u32_, data: *mut u32_,
                                      datasize: u8_, maskdata: *mut u32_,
                                      masksize: u8_) -> Result;
    pub fn GSPGPU_ReadHWRegs(regAddr: u32_, data: *mut u32_, size: u8_)
     -> Result;
    pub fn GSPGPU_RegisterInterruptRelayQueue(eventHandle: Handle,
                                              flags: u32_,
                                              outMemHandle: *mut Handle,
                                              threadID: *mut u8_) -> Result;
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
use ::types::*;
